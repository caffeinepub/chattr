{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Lobby initial chatroom load reliability (React Query canonicalization + robust loading/error states)",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Guarantee the Lobby triggers an initial unfiltered chatroom fetch (canonical key ['chatrooms']) after actor readiness on first page load.",
      "acceptanceCriteria": [
        "On a cold load of the live site Lobby, chatrooms render automatically (when they exist) without the user interacting with category badges.",
        "The unfiltered query for ['chatrooms'] executes after actor initialization, even if prior cached data for chatrooms is empty/stale.",
        "Clicking category filters still works and does not become the only way to populate the lobby list."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useForceFreshChatroomsOnActorReady.ts",
          "operation": "modify",
          "description": "Adjust the actor-ready effect to explicitly trigger a canonical ['chatrooms'] refetch/invalidation once the actor is available (in addition to updating cache), ensuring the React Query query function actually runs on first load even when an empty array was previously cached."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Update the base chatrooms query configuration to more reliably refetch after mount/actor readiness (e.g., ensure the canonical ['chatrooms'] query refetches on mount when enabled and does not get 'stuck' showing an empty cached result without attempting a network refresh)."
        },
        {
          "path": "frontend/src/pages/LobbyPage.tsx",
          "operation": "modify",
          "description": "Ensure Lobby always mounts and observes the canonical unfiltered chatroom query as the default data source, and that actor readiness transitions reliably lead to the unfiltered list populating without requiring any category interaction."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Canonicalize empty/whitespace search/category states to the base ['chatrooms'] key and remove/ignore any legacy empty-filter cache entries before rendering the Lobby list.",
      "acceptanceCriteria": [
        "No queries remain cached under keys shaped like ['chatrooms','search',''] or ['chatrooms','category',''] (including whitespace-only equivalents) after the actor becomes ready.",
        "When searchTerm and selectedCategory are empty/whitespace, the Lobby displays data from the canonical ['chatrooms'] query and not from any variant key.",
        "After clearing filters, the Lobby returns to showing the unfiltered list without requiring a manual refresh."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useForceFreshChatroomsOnActorReady.ts",
          "operation": "modify",
          "description": "Expand and harden legacy cache cleanup to remove any empty/whitespace chatroom variant keys (including older shapes), and ensure cleanup runs before the actor-ready forced refresh/refetch so stale empty variants cannot win the render."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Ensure query-key normalization is consistently applied so empty/whitespace search/category never produces variant cache keys (and cannot return empty arrays for the Lobby); keep variant queries disabled when trimmed input is empty so canonical ['chatrooms'] is the sole source of truth."
        },
        {
          "path": "frontend/src/pages/LobbyPage.tsx",
          "operation": "modify",
          "description": "Pass only trimmed/canonical filter inputs into the search/category hooks (and normalize category selection/clearing) so that empty/whitespace UI state always resolves to the base ['chatrooms'] query and clearing filters reliably restores the unfiltered list."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Prevent indefinite Lobby loading states and provide clear error UI with a working Retry that refetches the active query; keep cached data visible if background refresh fails.",
      "acceptanceCriteria": [
        "If the initial fetch fails, the Lobby shows an error state (not an infinite spinner) and the Retry button successfully re-attempts the appropriate fetch.",
        "If cached chatrooms exist and a background refresh fails, the Lobby continues to show the cached list and displays a non-blocking refresh error message.",
        "Loading UI only appears when a fetch is actually in-flight and there is no data to display yet (i.e., no permanent 'Loading chats...' state)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/LobbyPage.tsx",
          "operation": "modify",
          "description": "Refactor Lobby loading/error rendering to distinguish: (1) actor connecting, (2) initial data load with no data, (3) background refresh with cached data, and (4) hard error with no data; add a Retry action that calls the correct refetch for the currently active query (unfiltered/search/category) and ensure the UI cannot remain in a permanent spinner state."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Align chatroom query retry/placeholder behavior with the Lobby rendering model so initial failures surface as errors (not perpetual loading), while background failures can keep prior data and allow manual retry without wiping the list."
        }
      ]
    }
  ]
}