{
  "kind": "build_request",
  "title": "Add client-side compression for all image uploads",
  "priority": "normal",
  "requirements": [
    {
      "id": "REQ-1",
      "text": "Implement client-side image compression and apply it to every place the app uploads/serializes a user-selected image file (before converting to a data URL / storing in localStorage), including:\n- Avatar upload in `frontend/src/components/AvatarPickerDialog.tsx` (currently calls `uploadImage(file)` from `frontend/src/hooks/useQueries.ts`)\n- Chatroom media image upload in `frontend/src/components/CreateChatroomDialog.tsx` (currently calls `uploadImage(selectedFile, onProgress)` from `frontend/src/hooks/useQueries.ts`)\n- In-chat message image upload in `frontend/src/components/MessageInput.tsx` (currently uses a local `uploadImage(file)` implementation)\n\nCompression should:\n- Preserve correct orientation\n- Downscale large images to a reasonable maximum dimension\n- Reduce file size using an appropriate lossy format/quality setting\n- Fail gracefully (if compression fails, fall back to original image upload path and show an error only if the original path also fails).",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-6"
        ],
        "quotes": [
          "lets add compression to all image uploads"
        ]
      },
      "acceptanceCriteria": [
        "Uploading an image as an avatar, chatroom media image, or message image results in a visibly correct image and a smaller serialized payload than the original for typical large photos (e.g., multi-megapixel JPEGs).",
        "All image upload flows still work end-to-end: the returned `data:...;blob-storage-id=...;base64,...` URL continues to render correctly wherever images are displayed.",
        "If an image cannot be compressed (unsupported type, runtime error), the app still attempts to upload the original image; users are not blocked solely due to compression failure.",
        "No compression is applied to non-file media inputs (YouTube/Twitch/Twitter URLs) or to Giphy avatar selection (remote URL)."
      ]
    },
    {
      "id": "REQ-2",
      "text": "Refactor the code so all image uploads use a single shared upload/compress pipeline (avoid duplicated `uploadImage` logic), while keeping existing UI progress behavior:\n- Ensure `uploadImage` exported from `frontend/src/hooks/useQueries.ts` performs compression internally (or delegates to a shared helper) and still supports the existing optional `onProgress` callback.\n- Update `frontend/src/components/MessageInput.tsx` to use the shared `uploadImage` function rather than its local `uploadImage` implementation, so message image uploads are also compressed.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-6"
        ],
        "quotes": [
          "lets add compression to all image uploads"
        ]
      },
      "acceptanceCriteria": [
        "There is only one canonical image-upload function used by AvatarPickerDialog, CreateChatroomDialog, and MessageInput for File-based image uploads.",
        "`CreateChatroomDialog` progress UI continues to update (0â€“100%) during upload/serialization.",
        "`MessageInput` still shows its uploading progress UI and sends the message with `mediaType: 'image'` and a working `mediaUrl`."
      ]
    }
  ],
  "constraints": [
    "Do not modify files under `frontend/src/components/ui` (compose existing UI components instead).",
    "Do not edit immutable frontend hook files listed in SYSTEM_CONTEXT (e.g., `frontend/src/hooks/useActor.ts`, `frontend/src/main.tsx`, Internet Identity hooks).",
    "Keep the backend interface unchanged; image compression must happen on the client side before data URL creation/storage."
  ],
  "nonGoals": [
    "Adding new backend storage for images (e.g., canister chunk storage) or changing Motoko schemas for media.",
    "Compressing audio uploads/voice messages.",
    "Compressing images that are not uploaded as local files (e.g., external URLs such as Giphy)."
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  }
}